#! /bin/bash
MYNAME=$(basename $0)
MYDIR=$(dirname $0)
MYDIR=$(readlink -m "$MYDIR")
VERSION="0.0.5"
VERBOSE=""
LOGFILE=""
SERVER=""
PARENT_NAME=ubuntu
OWNER=${USER}
SSH="ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o LogLevel=quiet"
OPTION_NO_SSH_TEST=""
OPTION_TMP=""

#
# Prints the software version and exits.
#
function printVersionAndExit()
{
    echo "$MYNAME Version $VERSION on $(hostname)" >&2
}

#
# $*: the error message
#
# Prints an error message to the standard error. The text will not mixed up with
# the data that is printed to the standard output.
#
function printError()
{
    local datestring=$(date "+%Y-%m-%d %H:%M:%S")

    echo -e "$MYNAME($$) $*" >&2

    if [ "$LOGFILE" ]; then
        echo -e "$datestring ERROR $MYNAME($$) $*" >>"$LOGFILE"
    fi
}

#
# $*: the message
#
# Prints all the arguments but only if the program is in the verbose mode.
#
function printVerbose()
{
    local datestring=$(date "+%Y-%m-%d %H:%M:%S")

    if [ "$VERBOSE" == "true" ]; then
        echo -e "$*" >&2
    fi

    if [ "$LOGFILE" ]; then
        echo -e "$datestring DEBUG $MYNAME($$) $*" >>"$LOGFILE"
    fi
}

#
# https://unix.stackexchange.com/questions/30286/can-i-configure-my-linux-system-for-more-aggressive-file-system-caching
# http://www.networkinghowtos.com/howto/list-all-hard-disks-connected-to-a-ubuntu-system/
#
# Use this much percent of ram for cache
# echo 99 > /proc/sys/vm/dirty_ratio
#
# Use this much percent of ram before slowing down writer process.
# echo 50 > /proc/sys/vm/dirty_background_ratio
#
# It is ok to wait 1h before writing.
# echo 360000 > /proc/sys/vm/dirty_expire_centisecs
# echo 360000 > /proc/sys/vm/dirty_writeback_centisecs

function printHelpAndExit()
{
cat <<EOF
Usage:
  $MYNAME [OPTION]... [CONTAINER_NAME]...

  $MYNAME - Creates and starts containers.

 -h, --help           Print this help and exit.
 -v, --version        Print version information and exit.
 --verbose            Print more messages.
 --log-file=FILE      Store all the messages in the given file too.
 --server=SERVER      Create the container on remote server.
 --owner=USERNAME     The name of the user to be created.
 --no-ssh-test        Do not test the ssh connection to the container.
 --tmp                Create temporary container.

EXAMPLE

 pip-container-create --server=host01

EOF
    exit 0
}

ARGS=$(\
    getopt \
        -o hvs:c:l \
        -l "help,verbose,version,log-file:,server:,owner:,no-ssh-test,tmp" \
        -- "$@")

if [ $? -ne 0 ]; then
    exit 6
fi

eval set -- "$ARGS"
while true; do
    case "$1" in
        -h|--help)
            shift
            printHelpAndExit
            ;;

        --verbose)
            shift
            VERBOSE="true"
            VERBOSE_OPTION="--verbose"
            ;;

        -v|--version)
            shift
            VERSION_OPTION="--version"
            ;;

        --log-file)
            shift
            LOGFILE=$(readlink -m "$1")
            shift
            ;;

        --server)
            shift
            SERVER="$1"
            shift
            ;;

        --owner)
            shift
            OWNER="$1"
            shift
            ;;

        --no-ssh-test)
            shift
            OPTION_NO_SSH_TEST="true"
            ;;

        --tmp)
            shift
            OPTION_TMP="true"
            TMP_OPTION="--tmp"
            ;;

        --)
            shift
            break
            ;;

        *)
            ;;
    esac
done

#
# $*
# Container names are either coming from the command line or are automatically
# created.
#
function container_names()
{
    local number=1
    local node_name

    if [ "$1" ]; then
        echo $*
        return 0
    fi

    #
    # Finding a new name for the new node.
    #
    while true; do
        node_name=$(printf "node%03d" "$number")
        if [ ! -d "/var/lib/lxc/$node_name" ]; then
            echo "$node_name"
            return 0
        fi

        if [ "$number" -gt 100 ]; then
            printError "Could not find name for a new node."
            return 1
        fi

        let number+=1
    done
}

#
# This function will choose a server by checking how many containers are there
# on the individual servers.
#
function choose_server()
{
    local server
    local this_number
    local min_number
    local min_server
    local retval=0

    for server in $(echo $SERVER | tr ',' ' '); do
        this_number=$(\
            ssh -o UserKnownHostsFile=/dev/null \
                -o StrictHostKeyChecking=no \
                -o LogLevel=quiet \
                $server -- sudo lxc-ls  --running -f | wc -l)

        # The header line. :(
        let this_number-=1
        printVerbose "$this_number $server"

        if [ -z "$min_server" ]; then
            printVerbose "First $server"
            min_server="$server"
            min_number="$this_number"
        elif [ $this_number -lt $min_number ]; then
            printVerbose "Smaller $server"
            min_server="$server"
            min_number="$this_number"
        fi
    done

    if [ "$min_server" ]; then
        printVerbose "*** min_server: $min_server"
        echo "$min_server"
    fi
}

#
# Prints how many remote servers are provided in the --server command line
# option argument. If there are more than one server we chose one as a load
# balancer would do.
#
function number_of_servers()
{
    local server
    local retval=0

    for server in $(echo $SERVER | tr ',' ' '); do
        let retval+=1
    done

    echo $retval
}

#
# $1: the server name
#
function is_server_running_ssh()
{
    local serverName="$1"
    local owner="$2"
    local isOK

    isOk=$(sudo -u $owner -- ssh -o ConnectTimeout=1 -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o LogLevel=quiet "$serverName" 2>/dev/null -- echo OK)
    if [ "$isOk" == "OK" ]; then
        return 0
    fi

    return 1
}

#
# $2: the server name
#
# Waits until the server is accepting SSH connections. There is also a timeout
# implemented here.
#
function wait_for_server_ssh()
{
    local serverName="$1"
    local owner="$2"
    local nTry=0

    if [ "$OPTION_NO_SSH_TEST" ]; then
        return 0
    fi

    while true; do
        if is_server_running_ssh "$serverName" $owner; then
            printVerbose "Server '$serverName' is started."
            return 0
        fi

        # 120 x 5 = 10 minutes
        if [ "$nTry" -gt 120 ]; then
            printVerbose "Server '$serverName' did not came alive."
            return 1
        fi

        printVerbose "Server '$owner@$serverName' is not yet reachable."
        sleep 5
        let nTry+=1
    done

    return 0
}

#
# $1: the name of the new container.
# $2: the name of the parent container.
#
function create_container()
{
    local new_name="$1"
    local parent_name="$2"
    local ip

    if [ -z $(which "lxc-create") ]; then
        printVerbose "The lxc-create is not installed, attempting to install."
        apt install -y lxc1
    fi
    
    if [ -z $(which "lxc-create") ]; then
        printError "Could not install 'lxc-create' from package lxc1."
        exit 2
    fi

    if [ -z "$new_name" ]; then
        printError "No name for the new container, giving up."
        return 1
    fi

    if [ -d "/var/lib/lxc/$new_name" ]; then
        printError "The container '$new_name' already exists."
        return 1
    fi

    if [ ! -d "/var/lib/lxc/$parent_name" ]; then
        if [ "$parent_name" == "ubuntu" ]; then
            lxc-create \
                -t download -n ubuntu \
                -- \
                --dist ubuntu --release xenial --arch amd64
        fi
    fi
    
    if [ ! -d "/var/lib/lxc/$parent_name" ]; then
        printError "Could not create '$parent_name'."
        return 1
    fi

    # 
    # Creating the new container.
    #
    printVerbose "Creating container $new_name"

    location_option=""
    if [ "$OPTION_TMP" ]; then
        printVerbose "Creating ramdisk."
        mkdir /var/lib/lxc/$new_name
        mount -t tmpfs -o size=8G tmpfs /var/lib/lxc/$new_name
    fi
    
    lxc-copy $location_option -n $parent_name --newname="$new_name"
    lxc-start -n "$new_name"

    #
    # Creating the new user.
    #
    # lxc-attach -n node001 -- /usr/sbin/useradd --create-home --shell=/bin/bash pipas 
    lxc-attach -n "$new_name" -- \
        /usr/sbin/useradd --create-home --shell=/bin/bash "$OWNER" \
        2>/dev/null

    if [ $? -ne 0 ]; then
        printError "Could not create user $OWNER"
    fi

    #
    # Copying the SSH keys.
    #
    printVerbose "user     : $USER"
    printVerbose "OWNER    : $OWNER"
    printVerbose "new_name : $new_name"
    
    #sudo ls -lha /home/$OWNER
    #printVerbose \
    #    "/home/$OWNER/.ssh -> /var/lib/lxc/$new_name/rootfs/home/$OWNER"

    cp -r \
        "/home/$OWNER/.ssh" \
        "/var/lib/lxc/$new_name/rootfs/home/$OWNER/.ssh"

    lxc-attach -n "$new_name" -- \
        chown -R ${OWNER}.${OWNER} "/home/${OWNER}/.ssh" \
        2>/dev/null

    #ls -lha /var/lib/lxc/$new_name/rootfs/home/$OWNER

    #cp -r "/home/$OWNER/bin/" "/var/lib/lxc/$new_name/rootfs/home/$OWNER/"
    #lxc-execute -n "$new_name" -- \
    #    chown -R ${OWNER}.${OWNER} "/home/${OWNER}/bin" \
    #    2>/dev/null

    #
    # Adding to the sudoers.
    #
    echo "" >>"/var/lib/lxc/$new_name/rootfs/etc/sudoers"
    echo "${OWNER} ALL=(ALL) NOPASSWD:ALL" \
        >>"/var/lib/lxc/$new_name/rootfs/etc/sudoers"

    #
    # Installing some packages.
    #
    #lxc-execute -n "$new_name" -- apt-get -y --force-yes update
    #lxc-execute -n "$new_name" -- apt-get -y --force-yes upgrade
    #lxc-execute -n "$new_name" -- apt-get -y --force-yes install xauth vim-gtk3

    #
    # Starting the new container, showing the list.
    #
    #lxc-start -n "$new_name"

    #
    # 
    #
    while [ -z $ip ]; do
        ip=$(lxc-info -n "$new_name" -i | awk '{print $2}')

        if [ "$ip" == "-" ]; then
            ip=""
        fi

        if [ -z "$ip" ]; then
            printVerbose "Waiting for $new_name to get an IP."
            sleep 1
        fi
    done

    echo $ip
    wait_for_server_ssh $ip $OWNER

    return 0
}

#
# Checking command line arguments.
#
EXTRA_OPTIONS=$*

#if [ -z "$1" ]; then
#    printError "The arguments should be container name(s)."
#    exit 6
#fi

#
# Checking root privileges.
#
if [ -z "$SERVER" ]; then
    if [ "$EUID" -ne 0 ]; then 
        printError "This script has to have root privileges."
        exit 5
    fi
fi

#
# Doing the job. If this is a local call we create the container here, if it is
# a remote operation we ssh to the remote server and execute this same script 
# there.
#
if [ -z "$SERVER" ]; then
    # 
    # No server is provided, we execute locally.
    #
    if [ "$VERSION_OPTION" ]; then
        printVersionAndExit
        exit 0
    else
        for container in $(container_names $*); do
            create_container $container $PARENT_NAME
        done
    fi
else
    #
    # We received the --server option and so we run the script on a remote
    # server.
    #
    if [ $(number_of_servers) -gt 1 ]; then
        chosen_server=$(choose_server)
        printVerbose "Multiple servers... chose '$chosen_server'..."
    else
        chosen_server="$SERVER"
    fi

    if [ "$chosen_server" ]; then
        printVerbose "Executing on server '$chosen_server'."
        container_ip=$($SSH \
            $chosen_server -- \
            sudo $MYNAME \
                --owner="$OWNER" \
                --no-ssh-test \
                $VERSION_OPTION \
                $VERBOSE_OPTION \
                $TMP_OPTION \
                $EXTRA_OPTIONS)

        printVerbose "Executed on server '$chosen_server'."
        wait_for_server_ssh "$container_ip" "$OWNER"
        echo "$container_ip"
    else
        printError "No server found."
    fi
fi

